# Provide a custom message
message: ""

general:
  debug: false
  replicaCount: 1
  nameOverride: ""
  fullnameOverride: ""
  logLevel: info
  host: #0.0.0.0
  backend: #http://backend-podinfo:9898/echo
  backends: []

podSecurityContext:
  fsGroup: 1000

configMaps:
  create: false
  data:
    debug: info
    serverPort: "8000"
    appName: "styled-java-patterns"

secrets:
  create: false
  labels:
    app.kubernetes.io/component: vault
  data:
    baseUrl: ""
    baseToken: ""

ui:
  color: "#34577c"
  message: ""
  logo: ""

# failure conditions
faults:
  delay: false
  error: false
  unhealthy: false
  unready: false
  testFail: false
  testTimeout: false

service:
  enabled: true
  annotations: {}
  type: ClusterIP
#   port: 8193
#   portName: http
  httpPort: 8000
  externalPort: 8000
  nodePort: 8000
  # the port used to bind the http port to the host
  # NOTE: requires privileged container with NET_BIND_SERVICE capability -- this is useful for testing
  # in local clusters such as kind without port forwarding
  hostPort:
  discovery:
    enabled: false
    labels: {}
    annotations: {}

# enable h2c protocol (non-TLS version of HTTP/2)
h2c:
  enabled: false

networkPolicy:
  enabled: no
  ingress:
    # List of sources which should be able to access the CockroachDB Pods via
    # gRPC port. Items in this list are combined using a logical OR operation.
    # Rules for allowing inter-communication are applied automatically.
    # If empty, then connections from any Pod is allowed.
    grpc: []
      # - podSelector:
      #     matchLabels:
      #       app.kubernetes.io/name: my-app-django
      #       app.kubernetes.io/instance: my-app

    # List of sources which should be able to access the CockroachDB Pods via
    # HTTP port. Items in this list are combined using a logical OR operation.
    # If empty, then connections from any Pod is allowed.
    http: []
      # - namespaceSelector:
      #     matchLabels:
      #       project: my-project

storage:
  persistentVolumeClaim:
    enabled: false
    labels: {}
    annotations: {}

# enable tls on the podinfo service
tls:
  enabled: false
  # the name of the secret used to mount the certificate key pair
  secretName:
  # the path where the certificate key pair will be mounted
  certPath: /data/cert
  # the port used to host the tls endpoint on the service
  httpPort: 8000
  externalPort: 8000
  # the port used to bind the tls port to the host
  # NOTE: requires privileged container with NET_BIND_SERVICE capability -- this is useful for testing
  # in local clusters such as kind without port forwarding
  hostPort:

# create a certificate manager certificate (cert-manager required)
certificate:
  create: false
  # the issuer used to issue the certificate
  issuerRef:
    kind: ClusterIssuer
    name: self-signed
  # the hostname / subject alternative names for the certificate
  dnsNames:
    - localhost

# metrics-server add-on required
hpa:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80
  # average total CPU usage per pod (1-100)
  cpu:
  # average memory usage per pod (100Mi-1Gi)
  memory:
  # average http requests per second per pod (k8s-prometheus-adapter)
  requests:

serviceAccount:
  enabled: false
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# set container security context
securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# Remember to set service.type=ClusterIP if you are using an ingress
ingress:
  enabled: false
  className: ""
  annotations: {}
    ## Nginx ingress controller (default)
    # nginx.ingress.kubernetes.io/rewrite-target: /$1
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    # certmanager.k8s.io/cluster-issuer: letsencrypt-prod
  configured: false
  rewritePath: true
  pathPrefix: ""
  hosts:
    - host: podinfo.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

linkerd:
  profile:
    enabled: false

# create Prometheus Operator monitor
serviceMonitor:
  enabled: false
  interval: 15s
  labels: {}

virtualservice:
  enabled: false
  annotations: {}
  hosts:
    - host: ""
      names: []
      uris: {}
      rewrites: []
  serviceHost: ""

resources:
  limits:
    cpu: 500m
    memory: 1024Mi
  requests:
    cpu: 100m
    memory: 512Mi

statefulset:
  enabled: false
  replicas: 3
  updateStrategy:
    type: RollingUpdate
  podManagementPolicy: Parallel
  budget:
    maxUnavailable: 1

  # List of additional command-line arguments you want to pass to the
  # `start` command.
  args: []
    # - --disable-cluster-name-verification

  # List of extra environment variables to pass into container
  env: []
    # - name: ENGINE_MAX_SYNC_DURATION
    #   value: "24h"

  # List of Secrets names in the same Namespace as the cluster,
  # which shall be mounted into `/etc/path/secrets/` for every cluster
  # member.
  secretMounts: []

  # Additional labels to apply to this StatefulSet and all its Pods.
  labels:
    app.kubernetes.io/component: documentation

  # Additional annotations to apply to the Pods of this StatefulSet.
  annotations: {}

  # Affinity rules for scheduling Pods of this StatefulSet on Nodes.
  # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#node-affinity
  nodeAffinity: {}
  # Inter-Pod Affinity rules for scheduling Pods of this StatefulSet.
  # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  podAffinity: {}
  # Anti-affinity rules for scheduling Pods of this StatefulSet.
  # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  # You may either toggle options below for default anti-affinity rules,
  # or specify the whole set of anti-affinity rules instead of them.
  podAntiAffinity:
    # Type of anti-affinity rules: either `soft`, `hard` or empty value (which
    # disables anti-affinity rules).
    type: soft
    # Weight for `soft` anti-affinity rules.
    # Does not apply for other anti-affinity types.
    weight: 100

  # Node selection constraints for scheduling Pods of this StatefulSet.
  # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  nodeSelector: {}

  # Taints to be tolerated by Pods of this StatefulSet.
  # https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  tolerations: []

  # Uncomment the following resources definitions or pass them from
  # command line to control the CPU and memory resources allocated
  # by Pods of this StatefulSet.
  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 512Mi
    # requests:
    #   cpu: 100m
    #   memory: 512Mi

deployment:
  replicaCount: 2
  labels:
    app.kubernetes.io/component: documentation
  container:
    image:
      repository: "styled-java-patterns"
      tag: "latest" # uses chart appVersion if not provided
      pullPolicy: IfNotPresent
      pullSecrets: {}
      # command: ['./run.sh']
      # args: []
      credentials: {}
        # registry: docker.io
        # username: john_doe
        # password: changeme
    port: 8000

  resources:
    limits:
    requests:
      cpu: 1m
      memory: 16Mi

  # An arbitrary use of livenessProbe could make a lot of service interruption, use it wisely.
  livenessProbe:
    enabled: false
    config:
      httpGet:
        path: /actuator/health
        port: http
      initialDelaySeconds: 210
      periodSeconds: 60

  readinessProbe:
    enabled: false
    config:
      httpGet:
        path: /actuator/health
        port: http
      initialDelaySeconds: 180
      periodSeconds: 60

  # Currently only linux images on amd64 architecture are supported - support for arm64 and windows/amd64 coming ...
  nodeSelector: {}
#    kubernetes.io/os: linux
#    kubernetes.io/arch: amd64

  tolerations: []

  affinity: {}

  podAnnotations: {}
